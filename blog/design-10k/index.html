<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Designing a scalable blog platform | DDD</title><link rel=stylesheet href=https://grevyarlesp.github.io/homepage/css/style.css><link rel=stylesheet href=https://grevyarlesp.github.io/homepage/css/fonts.css><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<link rel=icon type=image/svg+xml href=https://grevyarlesp.github.io/homepage/favicon.svg><link rel=icon type=image/png href=https://grevyarlesp.github.io/homepage/favicon.png><link href="http://fonts.googleapis.com/css?family=Pacifico" rel=stylesheet type=text/css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel=stylesheet><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><nav><ul class=menu><li><a href=https://grevyarlesp.github.io/homepage/>home</a></li><li><a href=https://grevyarlesp.github.io/homepage/blog>blog</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Designing a scalable blog platform</span></h1><h2 class=date>2022/05/10</h2></div><main><p>A classic system design interview question is to design a blog platform. For this particular question, we design a system that can handle to 10000 requests per second.</p><h2 id=feature-expectations>Feature expectations:</h2><p>Since the question is very open-ended with no clear requirements, I am making up some feature requirements:</p><ul><li>Users can register and log in into their accounts</li><li>Users should be able to write their blogs in Markdown form (provides a markdown editor in client side)</li><li>Users can follow other users.</li><li>Users should be able to view blogs submitted by followed users, in form of a feed.</li><li>Blogs can contain images, but no videos.</li></ul><h2 id=estimations>Estimations:</h2><p>These are not accurate numbers, I looked them up from various sources to make our hypothetical design easier to work with:</p><ul><li>Each requests a blog, or send a blog to the server.</li><li>Each blog has 10000 characters (2 bytes for each, 20000 bytes), so each blog is 20KB.</li><li>Each blog may includes image, let&rsquo;s limit each to 2048 pixels (as Blogger does), so each image&rsquo;s size is around $2048 * 3 = 6144$. An average blog has 10 images (my assumption), so the total image size is around 12KB. Total size of an average blog post 32KB.</li><li><strong>Traffic</strong>: We have to serve 10000 requests per second, that puts it at $32 * 10000 = 320000$ KB, or 320MB of throughput per second. Compression is not considered here.</li><li><strong>Storage:</strong> Each of our users submits 2-3 blogs every day, let&rsquo;s put it at 20000-30000 blogs, so each month we have roughly 30GB more data. Or $30 * 365 \approx 11$ TB per year.</li></ul><h2 id=design-goals>Design goals</h2><p>We want our system to be:</p><ul><li>Highly <strong>available</strong></li><li>Optimized for read</li><li>Low lantecy (the blogs sent have to be fast)</li><li>Don&rsquo;t have to be consistent (when a user posts a blog, we don&rsquo;t need to be immediately distributed to other users).</li><li>Have to be tolerance to our network changes and not lose our data.</li></ul><h2 id=system-apis>System APIs</h2><ul><li><code>POST blog(user_key, blog_data)</code>: returns the URL of new blog.</li><li><code>POST image(user_key, image_data)</code>: uploads an image, return URL of new image.</li><li><code>POST follows(user_key, user2_id)</code>: The user follows another user. Unfollow if the user is already following.</li><li><code>GET blog(blog_id)</code>: returns URL of blog</li><li><code>GET image(image_id)</code>: returns URL of image</li><li><code>GET follower(user_key)</code>: returns a list of other users that this user is following.</li></ul><p>From this design, each of the feature expectations above can implemented.</p><p>This creates a bottleneck, if a user follow too many authors, the client has to do that many API calls to update his feed.</p><h2 id=high-level-design>High level design</h2><p align=center><img src=../img/design.svg alt="High level design"></p><p>Explanation of the chart:</p><ul><li>First, the client calls the load balancer. The load balancer divides up the workload between the web servers, it decides which server to handle each request. A level 4 load balancer should be sufficient.</li><li>The server clusters: Receive and process requests from the users.</li><li>Cache: Cache for Database. The webserver also hits this first before hitting the DB (if not data is not cached).</li><li>File storage stores our files: the markdown files and the image files.</li></ul><p>For the requirements of low latency, it make senses to use a Content Delivery Network.</p><h2 id=dive-into-each-components>Dive into each components</h2><p>Let&rsquo;s take a dive into each component of our design.</p><h3 id=load-balancing>Load balancing</h3><p>There are two types of load balancers: Hardware and software.</p><ul><li>Hardware load balancers are network devices, they usually have many CPU cores, memory and very high throughput.</li><li>Software load balancers: installed on small devices, with load balancing softwares. Can also be scaled up horizontally.</li></ul><p>There are several load balancing algorithms:</p><ul><li>Round robin</li><li>Least connection</li><li>Least response time</li></ul><p>Round robin is a good choice in this scenario, as the actual bottleneck is not with the web servers nor our load balancers.</p><h3 id=web-servers>Web servers</h3><p>The web servers are built as a cluster.</p><p>To ensure availability, we can divide add more web services, and use a service such as <strong>Zookeeper</strong> for discovery and health check.</p><p>The load balancer can hit on <strong>Zookeeper</strong> to check which servers are avaiable, then send the requests to the available web servers.</p><p>The web servers employ <strong>non-blocking IO</strong> method to handle and process web requests. It involves a queue on a single thread to serve the requests that come first, hits the database then continues on with the next requests, and return to the clients when the data is returned from the database. This is better for our system horizontal scaling.</p><p>An alternative method is <strong>blocking IO</strong>, in which we uses a separate thread for every connection, and it doesn&rsquo;t do anything until the database return the results. This is much more expensive than using <strong>non-blocking IO</strong>, as it requires more <strong>vertical scaling</strong>.</p><p>The trade off for non-blocking IO is that it is more complex and we have less control over our requests, we won&rsquo;t know if our database died and not returning the requests at all.</p><h3 id=database-design>Database design</h3><p>Define our tables:</p><p align=center><img src=../img/Schema.svg alt=database></p><p>With this simple database schema, we can fullfill all the above requirements.</p><p>Users&rsquo;s personal information can be stored as a JSON string, as we don&rsquo;t have to search for those.</p><p>Our database can be designed as a cluster, with a</p><p><strong>Replication</strong> is a method of for availability, also a method for scaling. In our case, we use it ensure the availability, incase any database falls.</p><p>Two methods for replication:</p><ul><li><p><strong>Master-slave</strong>: We have a single master and many slaves, which pull data from the master, serves as backup. Consistency is easy. In the event of master failure, a slave has to promoted to a master, and we have to restart our application.</p></li><li><p><strong>Master-master</strong>: Many masters share data with each other. In the event that a node goes down, the system can continue to operate. The trade-off that come with this is consistency. However, with many masters, our data can eventally be consistent.</p></li></ul><p align=center><img src=../img/db_design.svg alt=cdn></p><p>We need a load balancer for Master-master replication to speed up DB look up, a level 7 load balancer is approriate as it needs to know the content of the request.</p><p>We can use another cache to quickly look up commonly used searches.</p><h3 id=file-storage>File storage</h3><p>The markdown file stores references to our image ID, and the webserver can requests the files based on file ID (if they are stored in our system).</p><p>Content Delivery Network consists of many server globally, these are effectively caches, these are effectively caches.</p><p align=center><img src=../img/design_with_cdn.svg alt=cdn></p><p>When web servers receive the <code>GET</code> requests, it tries to <strong>pull</strong> from the CDN first before hitting the actual file storage.</p><p>Based on the region, the web server would periodically <strong>push</strong> most requested data to the CDN.</p><p>The similar thing happens when the web server needs to request someting from the database.</p><h2 id=bottlenecks-and-tradeoffs>Bottlenecks and tradeoffs</h2><p>No system is perfect, there has to some tradeoffs with our design.</p><p>A single load balancer can become a bottleneck and a single point of failure, for now one is enough.</p><h2 id=external-resources>External resources:</h2><ul><li>The template from: <a href=https://leetcode.com/discuss/career/229177/My-System-Design-Template>https://leetcode.com/discuss/career/229177/My-System-Design-Template</a></li><li><a href=https://github.com/donnemartin/system-design-primer>https://github.com/donnemartin/system-design-primer</a></li><li>This <a href=https://youtu.be/bUHFg8CZFws>video</a>, very informative, explains the operation of each of the components well.</li><li><strong>Designing Data-Intensive Applications</strong> book by Martin Kleppmann, informative on the design of each of the components.</li></ul></main><footer></footer></body></html>