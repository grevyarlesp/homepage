<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Designing a scalable blog platform | DDD</title><link rel=stylesheet href=https://grevyarlesp.github.io/homepage/css/style.css><link rel=stylesheet href=https://grevyarlesp.github.io/homepage/css/fonts.css><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<link rel=icon type=image/svg+xml href=https://grevyarlesp.github.io/homepage/favicon.svg><link rel=icon type=image/png href=https://grevyarlesp.github.io/homepage/favicon.png><link href="http://fonts.googleapis.com/css?family=Pacifico" rel=stylesheet type=text/css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel=stylesheet><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><nav><ul class=menu><li><a href=https://grevyarlesp.github.io/homepage/>home</a></li><li><a href=https://grevyarlesp.github.io/homepage/blog>blog</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Designing a scalable blog platform</span></h1><h2 class=date>2022/05/10</h2></div><main><p>A classic system design interview question is to design a blog platform. For this particular question, we design a system that can handle to 10000 requests per second.</p><h2 id=feature-expectations>Feature expectations:</h2><p>Since the question is very open-ended with no clear requirements, I am making up some feature requirements:</p><ul><li>Users can register and log in into their accounts</li><li>Users should be able to write their blogs in Markdown form (provides a markdown editor in client side)</li><li>Users can follow other users.</li><li>Users should be able to view blogs submitted by followed users, in form of a feed.</li><li>Blogs can contain images, but no videos.</li></ul><h2 id=estimations>Estimations:</h2><p>These are not accurate numbers, I looked them up from various sources to make our hypothetical design easier to work with:</p><ul><li>Each requests a blog, or send a blog to the server.</li><li>Each blog has 10000 characters (2 bytes for each, 20000 bytes), so each blog is 20KB.</li><li>Each blog may includes image, let&rsquo;s limit each to 2048 pixels (as Blogger does), so each image&rsquo;s size is around $2048 * 3 = 6144$. An average blog has 10 images (my assumption), so the total image size is around 12KB. Total size of an average blog post 32KB.</li><li><strong>Traffic</strong>: We have to serve 10000 requests per second, that puts it at $32 * 10000 = 320000$ KB, or 320MB of throughput per second. Compression is not considered here.</li><li><strong>Storage:</strong> Each of our users submits 2-3 blogs every day, let&rsquo;s put it at 20000-30000 blogs, so each month we have roughly 30GB more data. Or $30 * 365 \approx 11$ TB per year.</li></ul><h2 id=design-goals>Design goals</h2><p>We want our system to be:</p><ul><li>Highly available</li><li>Optimized for read</li><li>Low lantecy (the blogs sent have to be fast)</li><li>Don&rsquo;t have to be consistent (when a user posts a blog, we don&rsquo;t need to be immediately distributed to other users feed).</li><li>Have to be tolerance to our network changes and not lose our data.</li></ul><h2 id=system-apis>System APIs</h2><ul><li><code>POST blog(user_key, blog_data)</code>: returns the URL of new blog.</li><li><code>POST image(user_key, image_data)</code>: uploads an image, return URL of new image.</li><li><code>GET blog(blog_id)</code>: returns URL of blog</li><li><code>GET image(image_id)</code>: returns URL of image</li><li><code>GET follow(user_key)</code>: returns a list of other users that this user is following.</li></ul><p>From this design, each of the feature expectations above can implemented.</p><p>This creates a bottleneck, if a user follow too many authors, the client has to do that many API calls to update his feed.</p><h2 id=high-level-design>High level design</h2><p align=center><img src=../img/design.svg alt="High level design"></p><p>We can sketch out our high level design:</p><ul><li>First, the client calls the load balancer. The load balancer divides up the workload between the web servers, it decides which server to handle each request. A level 4 load balancer should be sufficient.</li><li>The server clusters: Receive and process requests from the users.</li><li>File storage stores our files: the markdown files and the image files.</li></ul><p>From the requirements of such high throughput, it make senses to add in a Content Delivery Network.</p><h2 id=dive-into-each-components>Dive into each components</h2><p>Let&rsquo;s take a dive into each component of our design.</p><h3 id=load-balancing>Load balancing</h3><p>There are two types of load balancers: Hardware and software.</p><ul><li>Hardware load balancers are network devices, they usually have many CPU cores, memory and very high throughput.</li><li>Software load balancers: installed on small devices, can also be used</li></ul><p>There are several load balancing algorithms:</p><ul><li>Round robin</li><li>Least connection</li><li>Least response time</li></ul><p>Round robin is a good choice in this scenario, as the actual bottleneck is not with the web servers.</p><h3 id=web-servers>Web servers</h3><p>The web servers are built as a cluster.</p><p>To ensure availability, we can divide add more web services, and use a service such as <strong>Zookeeper</strong> for discovery and health check.</p><p>The load balancer can hit on <strong>Zookeeper</strong> to check which servers are avaiable, then send the requests to the available web servers.</p><p>The web servers employ <strong>non-blocking IO</strong> method to handle and process web requests. It involves a queue serve the requests that come first,</p><h3 id=database-design>Database design</h3><p>Define our tables:</p><p align=center><img src=../img/Schema.svg alt=database></p><p>With this simple database schema, we can fullfill all the above requirements.</p><p>Users&rsquo;s personal information can be stored as a JSON string, as we don&rsquo;t have to search for those.</p><p>Our database can be designed as a cluster, with a</p><p><strong>Replication</strong> is a method of for availability, also a method for scaling. In our case, we use it ensure the availability, incase any database falls.</p><h3 id=file-storage>File storage</h3><p>Content Delivery Network consists of many server globally, these are effectively caches, these are effectively caches.</p><p align=center><img src=../img/design_with_cdn.svg alt=cdn></p><p>When web servers receive the <code>GET</code> requests, it tries to <strong>pull</strong> from the CDN first before hitting the actual file storage.</p><p>Based on the region, the file storage periodically would <strong>push</strong> most requested data to the CDN.</p><h2 id=bottlenecks-and-tradeoffs>Bottlenecks and tradeoffs</h2><h2 id=external-resources>External resources:</h2><ul><li>The template from: <a href=https://leetcode.com/discuss/career/229177/My-System-Design-Template>https://leetcode.com/discuss/career/229177/My-System-Design-Template</a></li><li><a href=https://github.com/donnemartin/system-design-primer>https://github.com/donnemartin/system-design-primer</a></li><li>This <a href=https://youtu.be/bUHFg8CZFws>video</a>, very informative, explains the operation of each of the components well.</li><li><strong>Designing Data-Intensive Applications</strong> book by Martin Kleppmann, informative on the design of each of the components.</li></ul></main><footer></footer></body></html>